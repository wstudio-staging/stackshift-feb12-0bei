"use strict";(self.webpackChunk_webriq_pagebuilder_site_template_default=self.webpackChunk_webriq_pagebuilder_site_template_default||[]).push([[2664],{"./node_modules/@sanity/groq-store/dist/index.browser.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function groq(strings){for(var _len=arguments.length,keys=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)keys[_key-1]=arguments[_key];const lastIndex=strings.length-1;return strings.slice(0,lastIndex).reduce(((acc,str,i)=>acc+str+keys[i]),"")+strings[lastIndex]}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{groq:()=>groq,groqStore:()=>groqStore});var fast_deep_equal=__webpack_require__("./node_modules/fast-deep-equal/index.js"),fast_deep_equal_default=__webpack_require__.n(fast_deep_equal);function throttle(delay,callback,options){var timeoutID,_ref=options||{},_ref$noTrailing=_ref.noTrailing,noTrailing=void 0!==_ref$noTrailing&&_ref$noTrailing,_ref$noLeading=_ref.noLeading,noLeading=void 0!==_ref$noLeading&&_ref$noLeading,_ref$debounceMode=_ref.debounceMode,debounceMode=void 0===_ref$debounceMode?void 0:_ref$debounceMode,cancelled=!1,lastExec=0;function clearExistingTimeout(){timeoutID&&clearTimeout(timeoutID)}function wrapper(){for(var _len=arguments.length,arguments_=new Array(_len),_key=0;_key<_len;_key++)arguments_[_key]=arguments[_key];var self=this,elapsed=Date.now()-lastExec;function exec(){lastExec=Date.now(),callback.apply(self,arguments_)}function clear(){timeoutID=void 0}cancelled||(noLeading||!debounceMode||timeoutID||exec(),clearExistingTimeout(),void 0===debounceMode&&elapsed>delay?noLeading?(lastExec=Date.now(),noTrailing||(timeoutID=setTimeout(debounceMode?clear:exec,delay))):exec():!0!==noTrailing&&(timeoutID=setTimeout(debounceMode?clear:exec,void 0===debounceMode?delay-elapsed:delay)))}return wrapper.cancel=function cancel(options){var _ref2$upcomingOnly=(options||{}).upcomingOnly,upcomingOnly=void 0!==_ref2$upcomingOnly&&_ref2$upcomingOnly;clearExistingTimeout(),cancelled=!upcomingOnly},wrapper}class Path{constructor(pattern){this.pattern=pattern,this.patternRe=function pathRegExp(pattern){const re=[];for(const part of pattern.split("."))"*"===part?re.push("[^.]+"):"**"===part?re.push(".*"):re.push(part.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"));return new RegExp("^".concat(re.join("."),"$"))}(pattern)}matches(str){return this.patternRe.test(str)}toJSON(){return this.pattern}}class StreamValue{constructor(generator){this.type="stream",this.generator=generator,this.ticker=null,this.isDone=!1,this.data=[]}isArray(){return!0}async get(){const result=[];for await(const value of this)result.push(await value.get());return result}async*[Symbol.asyncIterator](){let i=0;for(;;){for(;i<this.data.length;i++)yield this.data[i];if(this.isDone)return;await this._nextTick()}}_nextTick(){if(this.ticker)return this.ticker;let currentResolver;const setupTicker=()=>{this.ticker=new Promise((resolve=>{currentResolver=resolve}))},tick=()=>{currentResolver(),setupTicker()};return setupTicker(),(async()=>{for await(const value of this.generator())this.data.push(value),tick();this.isDone=!0,tick()})(),this.ticker}}const RFC3339_REGEX=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([-+]\d{2}:\d{2}))$/;function addLeadingZero(num,targetLength){let str=num.toString();for(;str.length<targetLength;)str="0".concat(str);return str}class StaticValue{constructor(data,type){this.data=data,this.type=type}isArray(){return"array"===this.type}async get(){return this.data}[Symbol.asyncIterator](){if(Array.isArray(this.data))return function*(data){for(const element of data)yield fromJS(element)}(this.data);throw new Error("Cannot iterate over: ".concat(this.type))}}const NULL_VALUE=new StaticValue(null,"null"),TRUE_VALUE=new StaticValue(!0,"boolean"),FALSE_VALUE=new StaticValue(!1,"boolean");class DateTime{constructor(date){this.date=date}static parseToValue(str){const date=function parseRFC3339(str){return RFC3339_REGEX.test(str)?new Date(str):null}(str);return date?new StaticValue(new DateTime(date),"datetime"):NULL_VALUE}equals(other){return this.date.getTime()==other.date.getTime()}add(secs){const copy=new Date(this.date.getTime());return copy.setTime(copy.getTime()+1e3*secs),new DateTime(copy)}difference(other){return(this.date.getTime()-other.date.getTime())/1e3}compareTo(other){return this.date.getTime()-other.date.getTime()}toString(){return function formatRFC3339(d){const year=addLeadingZero(d.getUTCFullYear(),4),month=addLeadingZero(d.getUTCMonth()+1,2),day=addLeadingZero(d.getUTCDate(),2),hour=addLeadingZero(d.getUTCHours(),2),minute=addLeadingZero(d.getUTCMinutes(),2),second=addLeadingZero(d.getUTCSeconds(),2);let fractionalSecond="";const millis=d.getMilliseconds();return 0!=millis&&(fractionalSecond=".".concat(addLeadingZero(millis,3))),"".concat(year,"-").concat(month,"-").concat(day,"T").concat(hour,":").concat(minute,":").concat(second).concat(fractionalSecond,"Z")}(this.date)}toJSON(){return this.toString()}}function fromNumber(num){return Number.isFinite(num)?new StaticValue(num,"number"):NULL_VALUE}function fromString(str){return new StaticValue(str,"string")}function fromDateTime(dt){return new StaticValue(dt,"datetime")}function fromJS(val){return function isIterator(obj){return obj&&"function"==typeof obj.next}(val)?new StreamValue((async function*(){for await(const value of val)yield fromJS(value)})):null==val?NULL_VALUE:new StaticValue(val,getType(val))}function getType(data){return null==data?"null":Array.isArray(data)?"array":data instanceof Path?"path":data instanceof DateTime?"datetime":typeof data}function isEqual(a,b){return"string"===a.type&&"string"===b.type||"boolean"===a.type&&"boolean"===b.type||"null"===a.type&&"null"===b.type||"number"===a.type&&"number"===b.type?a.data===b.data:"datetime"===a.type&&"datetime"===b.type&&a.data.equals(b.data)}const CHARS=/([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g,CHARS_WITH_WILDCARD=/([^!@#$%^&(),\\/?";:{}|[\]+<>\s-])+/g,EDGE_CHARS=/(\b\.+|\.+\b)/g,MAX_TERM_LENGTH=1024;function matchTokenize(text){return text.replace(EDGE_CHARS,"").match(CHARS)||[]}function matchPatternRegex(text){return(text.replace(EDGE_CHARS,"").match(CHARS_WITH_WILDCARD)||[]).map((term=>new RegExp("^".concat(term.slice(0,MAX_TERM_LENGTH).replace(/\*/g,".*"),"$"),"i")))}async function gatherText(value,cb){if("string"===value.type)return cb(value.data),!0;if(value.isArray()){let success=!0;for await(const part of value)"string"===part.type?cb(part.data):success=!1;return success}return!1}const TYPE_ORDER={datetime:1,number:2,string:3,boolean:4};function partialCompare(a,b){const aType=getType(a);if(aType!==getType(b))return null;switch(aType){case"number":case"boolean":return a-b;case"string":return a<b?-1:a>b?1:0;case"datetime":return a.compareTo(b);default:return null}}function totalCompare(a,b){const aType=getType(a),bType=getType(b),aTypeOrder=TYPE_ORDER[aType]||100,bTypeOrder=TYPE_ORDER[bType]||100;if(aTypeOrder!==bTypeOrder)return aTypeOrder-bTypeOrder;let result=partialCompare(a,b);return null===result&&(result=0),result}const operators={"==":function eq(left,right){return isEqual(left,right)?TRUE_VALUE:FALSE_VALUE},"!=":function neq(left,right){return isEqual(left,right)?FALSE_VALUE:TRUE_VALUE},">":function gt(left,right){if("stream"===left.type||"stream"===right.type)return NULL_VALUE;const result=partialCompare(left.data,right.data);return null===result?NULL_VALUE:result>0?TRUE_VALUE:FALSE_VALUE},">=":function gte(left,right){if("stream"===left.type||"stream"===right.type)return NULL_VALUE;const result=partialCompare(left.data,right.data);return null===result?NULL_VALUE:result>=0?TRUE_VALUE:FALSE_VALUE},"<":function lt(left,right){if("stream"===left.type||"stream"===right.type)return NULL_VALUE;const result=partialCompare(left.data,right.data);return null===result?NULL_VALUE:result<0?TRUE_VALUE:FALSE_VALUE},"<=":function lte(left,right){if("stream"===left.type||"stream"===right.type)return NULL_VALUE;const result=partialCompare(left.data,right.data);return null===result?NULL_VALUE:result<=0?TRUE_VALUE:FALSE_VALUE},in:async function inop(left,right){if("path"===right.type)return"string"!==left.type?NULL_VALUE:right.data.matches(left.data)?TRUE_VALUE:FALSE_VALUE;if(right.isArray()){for await(const b of right)if(isEqual(left,b))return TRUE_VALUE;return FALSE_VALUE}return NULL_VALUE},match:async function match(left,right){let tokens=[],patterns=[];await gatherText(left,(part=>{tokens=tokens.concat(matchTokenize(part))}));const didSucceed=await gatherText(right,(part=>{patterns=patterns.concat(function matchAnalyzePattern(text){return matchPatternRegex(text).map((re=>tokens=>tokens.some((token=>re.test(token)))))}(part))}));if(!didSucceed)return FALSE_VALUE;const matched=function matchText(tokens,patterns){return 0!==tokens.length&&0!==patterns.length&&patterns.every((pattern=>pattern(tokens)))}(tokens,patterns);return matched?TRUE_VALUE:FALSE_VALUE},"+":function plus(left,right){return"datetime"===left.type&&"number"===right.type?fromDateTime(left.data.add(right.data)):"number"===left.type&&"number"===right.type?fromNumber(left.data+right.data):"string"===left.type&&"string"===right.type?fromString(left.data+right.data):"object"===left.type&&"object"===right.type?fromJS({...left.data,...right.data}):"array"===left.type&&"array"===right.type?fromJS(left.data.concat(right.data)):left.isArray()&&right.isArray()?new StreamValue((async function*(){for await(const val of left)yield val;for await(const val of right)yield val})):NULL_VALUE},"-":function minus(left,right){return"datetime"===left.type&&"number"===right.type?fromDateTime(left.data.add(-right.data)):"datetime"===left.type&&"datetime"===right.type?fromNumber(left.data.difference(right.data)):"number"===left.type&&"number"===right.type?fromNumber(left.data-right.data):NULL_VALUE},"*":numericOperator(((a,b)=>a*b)),"/":numericOperator(((a,b)=>a/b)),"%":numericOperator(((a,b)=>a%b)),"**":numericOperator(((a,b)=>Math.pow(a,b)))};function numericOperator(impl){return function(left,right){if("number"===left.type&&"number"===right.type){return fromNumber(impl(left.data,right.data))}return NULL_VALUE}}class Scope{constructor(params,source,value,context,parent){this.isHidden=!1,this.params=params,this.source=source,this.value=value,this.context=context,this.parent=parent}createNested(value){return this.isHidden?new Scope(this.params,this.source,value,this.context,this.parent):new Scope(this.params,this.source,value,this.context,this)}createHidden(value){const result=this.createNested(value);return result.isHidden=!0,result}}function evaluate(node,scope){let execute=arguments.length>2&&void 0!==arguments[2]?arguments[2]:evaluate;return(0,EXECUTORS[node.type])(node,scope,execute)}function promiselessApply(value,cb){return"then"in value?value.then(cb):cb(value)}const EXECUTORS={This:(_,scope)=>scope.value,Selector(){throw new Error("Selectors can not be evaluated")},Everything:(_,scope)=>scope.source,Parameter(_ref,scope){let{name}=_ref;return fromJS(scope.params[name])},Context(_ref2,scope){let{key}=_ref2;if("before"===key||"after"===key){return scope.context[key]||NULL_VALUE}throw new Error("unknown context key: ".concat(key))},Parent(_ref3,scope){let{n}=_ref3,current=scope;for(let i=0;i<n;i++){if(!current.parent)return NULL_VALUE;current=current.parent}return current.value},OpCall(_ref4,scope,execute){let{op,left,right}=_ref4;const func=operators[op];if(!func)throw new Error("Unknown operator: ".concat(op));const leftValue=execute(left,scope),rightValue=execute(right,scope);return"then"in leftValue||"then"in rightValue?(async()=>func(await leftValue,await rightValue))():func(leftValue,rightValue)},async Select(_ref5,scope,execute){let{alternatives,fallback}=_ref5;for(const alt of alternatives){const altCond=await execute(alt.condition,scope);if("boolean"===altCond.type&&!0===altCond.data)return execute(alt.value,scope)}return fallback?execute(fallback,scope):NULL_VALUE},async InRange(_ref6,scope,execute){let{base,left,right,isInclusive}=_ref6;const value=await execute(base,scope),leftValue=await execute(left,scope),rightValue=await execute(right,scope),leftCmp=partialCompare(await value.get(),await leftValue.get());if(null===leftCmp)return NULL_VALUE;const rightCmp=partialCompare(await value.get(),await rightValue.get());return null===rightCmp?NULL_VALUE:isInclusive?leftCmp>=0&&rightCmp<=0?TRUE_VALUE:FALSE_VALUE:leftCmp>=0&&rightCmp<0?TRUE_VALUE:FALSE_VALUE},async Filter(_ref7,scope,execute){let{base,expr}=_ref7;const baseValue=await execute(base,scope);return baseValue.isArray()?new StreamValue((async function*(){for await(const elem of baseValue){const newScope=scope.createNested(elem),exprValue=await execute(expr,newScope);"boolean"===exprValue.type&&!0===exprValue.data&&(yield elem)}})):NULL_VALUE},async Projection(_ref8,scope,execute){let{base,expr}=_ref8;const baseValue=await execute(base,scope);if("object"!==baseValue.type)return NULL_VALUE;return execute(expr,scope.createNested(baseValue))},FuncCall(_ref9,scope,execute){let{func,args}=_ref9;return func(args,scope,execute)},async PipeFuncCall(_ref10,scope,execute){let{func,base,args}=_ref10;return func(await execute(base,scope),args,scope,execute)},async AccessAttribute(_ref11,scope,execute){let{base,name}=_ref11,value=scope.value;return base&&(value=await execute(base,scope)),"object"===value.type&&value.data.hasOwnProperty(name)?fromJS(value.data[name]):NULL_VALUE},async AccessElement(_ref12,scope,execute){let{base,index}=_ref12;const baseValue=await execute(base,scope);if(!baseValue.isArray())return NULL_VALUE;const data=await baseValue.get();return fromJS(data[index<0?index+data.length:index])},async Slice(_ref13,scope,execute){let{base,left,right,isInclusive}=_ref13;const baseValue=await execute(base,scope);if(!baseValue.isArray())return NULL_VALUE;const array=await baseValue.get();let leftIdx=left,rightIdx=right;return leftIdx<0&&(leftIdx=array.length+leftIdx),rightIdx<0&&(rightIdx=array.length+rightIdx),isInclusive&&rightIdx++,leftIdx<0&&(leftIdx=0),rightIdx<0&&(rightIdx=0),fromJS(array.slice(leftIdx,rightIdx))},async Deref(_ref14,scope,execute){let{base}=_ref14;const value=await execute(base,scope);if(!scope.source.isArray())return NULL_VALUE;if("object"!==value.type)return NULL_VALUE;const id=value.data._ref;if("string"!=typeof id)return NULL_VALUE;for await(const doc of scope.source)if("object"===doc.type&&id===doc.data._id)return doc;return NULL_VALUE},Value(_ref15){let{value}=_ref15;return fromJS(value)},Group(_ref16,scope,execute){let{base}=_ref16;return execute(base,scope)},async Object(_ref17,scope,execute){let{attributes}=_ref17;const result={};for(const attr of attributes){const attrType=attr.type;switch(attr.type){case"ObjectAttributeValue":{const value=await execute(attr.value,scope);result[attr.name]=await value.get();break}case"ObjectConditionalSplat":{const cond=await execute(attr.condition,scope);if("boolean"!==cond.type||!1===cond.data)continue;const value=await execute(attr.value,scope);"object"===value.type&&Object.assign(result,value.data);break}case"ObjectSplat":{const value=await execute(attr.value,scope);"object"===value.type&&Object.assign(result,value.data);break}default:throw new Error("Unknown node type: ".concat(attrType))}}return fromJS(result)},Array(_ref18,scope,execute){let{elements}=_ref18;return new StreamValue((async function*(){for(const element of elements){const value=await execute(element.value,scope);if(element.isSplat){if(value.isArray())for await(const v of value)yield v}else yield value}}))},Tuple(){throw new Error("tuples can not be evaluated")},async Or(_ref19,scope,execute){let{left,right}=_ref19;const leftValue=await execute(left,scope),rightValue=await execute(right,scope);return"boolean"===leftValue.type&&!0===leftValue.data||"boolean"===rightValue.type&&!0===rightValue.data?TRUE_VALUE:"boolean"!==leftValue.type||"boolean"!==rightValue.type?NULL_VALUE:FALSE_VALUE},async And(_ref20,scope,execute){let{left,right}=_ref20;const leftValue=await execute(left,scope),rightValue=await execute(right,scope);return"boolean"===leftValue.type&&!1===leftValue.data||"boolean"===rightValue.type&&!1===rightValue.data?FALSE_VALUE:"boolean"!==leftValue.type||"boolean"!==rightValue.type?NULL_VALUE:TRUE_VALUE},async Not(_ref21,scope,execute){let{base}=_ref21;const value=await execute(base,scope);return"boolean"!==value.type?NULL_VALUE:value.data?FALSE_VALUE:TRUE_VALUE},Neg(_ref22,scope,execute){let{base}=_ref22;return promiselessApply(execute(base,scope),(value=>"number"!==value.type?NULL_VALUE:fromNumber(-value.data)))},Pos(_ref23,scope,execute){let{base}=_ref23;return promiselessApply(execute(base,scope),(value=>"number"!==value.type?NULL_VALUE:fromNumber(value.data)))},Asc:()=>NULL_VALUE,Desc:()=>NULL_VALUE,async ArrayCoerce(_ref24,scope,execute){let{base}=_ref24;const value=await execute(base,scope);return value.isArray()?value:NULL_VALUE},async Map(_ref25,scope,execute){let{base,expr}=_ref25;const value=await execute(base,scope);return value.isArray()?new StreamValue((async function*(){for await(const elem of value){const newScope=scope.createHidden(elem);yield await execute(expr,newScope)}})):NULL_VALUE},async FlatMap(_ref26,scope,execute){let{base,expr}=_ref26;const value=await execute(base,scope);return value.isArray()?new StreamValue((async function*(){for await(const elem of value){const newScope=scope.createHidden(elem),innerValue=await execute(expr,newScope);if(innerValue.isArray())for await(const inner of innerValue)yield inner;else yield innerValue}})):NULL_VALUE}};function canConstantEvaluate(node){switch(node.type){case"Group":case"Value":case"Parameter":return!0;case"Pos":case"Neg":return canConstantEvaluate(node.base);case"OpCall":switch(node.op){case"+":case"-":case"*":case"/":case"%":case"**":return canConstantEvaluate(node.left)&&canConstantEvaluate(node.right);default:return!1}default:return!1}}const DUMMY_SCOPE=new Scope({},NULL_VALUE,NULL_VALUE,{timestamp:new Date(0),identity:"me",before:null,after:null},null);function tryConstantEvaluate(node){return canConstantEvaluate(node)?constantEvaluate(node):null}function constantEvaluate(node){const value=evaluate(node,DUMMY_SCOPE,constantEvaluate);if("then"in value)throw new Error("BUG: constant evaluate should never return a promise");return value}async function portableTextContent(value){if("object"===value.type)return blockText(value.data);if(value.isArray()){const texts=await arrayText(value);if(texts.length>0)return texts.join("\n\n")}return null}async function arrayText(value){let result=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];for await(const block of value)if("object"===block.type){const text=blockText(block.data);null!==text&&result.push(text)}else block.isArray()&&await arrayText(block,result);return result}function blockText(obj){if("string"!=typeof obj._type)return null;const children=obj.children;if(!Array.isArray(children))return null;let result="";for(const child of children)child&&"object"==typeof child&&"string"==typeof child._type&&"span"===child._type&&"string"==typeof child.text&&(result+=child.text);return result}const BM25k=1.2;async function evaluateScore(node,scope,execute){if("OpCall"===node.type&&"match"===node.op)return async function evaluateMatchScore(left,right,scope,execute){const text=await execute(left,scope),pattern=await execute(right,scope);let tokens=[],terms=[];await gatherText(text,(part=>{tokens=tokens.concat(matchTokenize(part))}));if(!await gatherText(pattern,(part=>{terms=terms.concat(matchPatternRegex(part))})))return 0;if(0===tokens.length||0===terms.length)return 0;let score=0;for(const re of terms){const freq=tokens.reduce(((c,token)=>c+(re.test(token)?1:0)),0);score+=freq*(BM25k+1)/(freq+BM25k)}return score}(node.left,node.right,scope,execute);if("FuncCall"===node.type&&"boost"===node.name){const innerScore=await evaluateScore(node.args[0],scope,execute),boost=await execute(node.args[1],scope);return"number"===boost.type&&innerScore>0?innerScore+boost.data:0}switch(node.type){case"Or":return await evaluateScore(node.left,scope,execute)+await evaluateScore(node.right,scope,execute);case"And":{const leftScore=await evaluateScore(node.left,scope,execute),rightScore=await evaluateScore(node.right,scope,execute);return 0===leftScore||0===rightScore?0:leftScore+rightScore}default:{const res=await execute(node,scope);return"boolean"===res.type&&!0===res.data?1:0}}}function hasReference(value,pathSet){switch(getType(value)){case"array":for(const v of value)if(hasReference(v,pathSet))return!0;break;case"object":if(value._ref)return pathSet.has(value._ref);for(const v of Object.values(value))if(hasReference(v,pathSet))return!0}return!1}const _global={anywhere:async function anywhere(){throw new Error("not implemented")}};_global.anywhere.arity=1,_global.coalesce=async function coalesce(args,scope,execute){for(const arg of args){const value=await execute(arg,scope);if("null"!==value.type)return value}return NULL_VALUE},_global.count=async function count(args,scope,execute){const inner=await execute(args[0],scope);if(!inner.isArray())return NULL_VALUE;let num=0;for await(const _ of inner)num++;return fromNumber(num)},_global.count.arity=1,_global.dateTime=async function dateTime(args,scope,execute){const val=await execute(args[0],scope);return"datetime"===val.type?val:"string"!==val.type?NULL_VALUE:DateTime.parseToValue(val.data)},_global.dateTime.arity=1,_global.defined=async function defined(args,scope,execute){return"null"===(await execute(args[0],scope)).type?FALSE_VALUE:TRUE_VALUE},_global.defined.arity=1,_global.identity=async function identity(args,scope){return fromString(scope.context.identity)},_global.identity.arity=0,_global.length=async function length(args,scope,execute){const inner=await execute(args[0],scope);if("string"===inner.type)return fromNumber(function countUTF8(str){let count2=0;for(let i=0;i<str.length;i++){const code=str.charCodeAt(i);code>=55296&&code<=56319||count2++}return count2}(inner.data));if(inner.isArray()){let num=0;for await(const _ of inner)num++;return fromNumber(num)}return NULL_VALUE},_global.length.arity=1,_global.path=async function path(args,scope,execute){const inner=await execute(args[0],scope);return"string"!==inner.type?NULL_VALUE:function fromPath(path){return new StaticValue(path,"path")}(new Path(inner.data))},_global.path.arity=1,_global.string=async function string(args,scope,execute){const value=await execute(args[0],scope);switch(value.type){case"number":case"string":case"boolean":case"datetime":return fromString("".concat(value.data));default:return NULL_VALUE}},_global.string.arity=1,_global.references=async function references(args,scope,execute){const pathSet=new Set;for(const arg of args){const path2=await execute(arg,scope);if("string"===path2.type)pathSet.add(path2.data);else if(path2.isArray())for await(const elem of path2)"string"===elem.type&&pathSet.add(elem.data)}if(0===pathSet.size)return FALSE_VALUE;return hasReference(await scope.value.get(),pathSet)?TRUE_VALUE:FALSE_VALUE},_global.references.arity=c=>c>=1,_global.round=async function round(args,scope,execute){const value=await execute(args[0],scope);if("number"!==value.type)return NULL_VALUE;const num=value.data;let prec=0;if(2===args.length){const precValue=await execute(args[1],scope);if("number"!==precValue.type||precValue.data<0||!Number.isInteger(precValue.data))return NULL_VALUE;prec=precValue.data}return fromNumber(0===prec?num<0?-Math.round(-num):Math.round(num):Number(num.toFixed(prec)))},_global.round.arity=count2=>count2>=1&&count2<=2,_global.now=async function now(args,scope){return fromString(scope.context.timestamp.toISOString())},_global.now.arity=0,_global.boost=async function boost(){throw new Error("unexpected boost call")},_global.boost.arity=2;const string2={lower:async function(args,scope,execute){const value=await execute(args[0],scope);return"string"!==value.type?NULL_VALUE:fromString(value.data.toLowerCase())}};string2.lower.arity=1,string2.upper=async function(args,scope,execute){const value=await execute(args[0],scope);return"string"!==value.type?NULL_VALUE:fromString(value.data.toUpperCase())},string2.upper.arity=1,string2.split=async function(args,scope,execute){const str=await execute(args[0],scope);if("string"!==str.type)return NULL_VALUE;const sep=await execute(args[1],scope);return"string"!==sep.type?NULL_VALUE:0===str.data.length?fromJS([]):0===sep.data.length?fromJS(Array.from(str.data)):fromJS(str.data.split(sep.data))},string2.split.arity=2,_global.lower=string2.lower,_global.upper=string2.upper,string2.startsWith=async function(args,scope,execute){const str=await execute(args[0],scope);if("string"!==str.type)return NULL_VALUE;const prefix=await execute(args[1],scope);return"string"!==prefix.type?NULL_VALUE:str.data.startsWith(prefix.data)?TRUE_VALUE:FALSE_VALUE},string2.startsWith.arity=2;const array={join:async function(args,scope,execute){const arr=await execute(args[0],scope);if(!arr.isArray())return NULL_VALUE;const sep=await execute(args[1],scope);if("string"!==sep.type)return NULL_VALUE;let buf="",needSep=!1;for await(const elem of arr){switch(needSep&&(buf+=sep.data),elem.type){case"number":case"string":case"boolean":case"datetime":buf+="".concat(elem.data);break;default:return NULL_VALUE}needSep=!0}return fromJS(buf)}};array.join.arity=2,array.compact=async function(args,scope,execute){const arr=await execute(args[0],scope);return arr.isArray()?new StreamValue((async function*(){for await(const elem of arr)"null"!==elem.type&&(yield elem)})):NULL_VALUE},array.compact.arity=1,array.unique=async function(args,scope,execute){const value=await execute(args[0],scope);return value.isArray()?new StreamValue((async function*(){const added=new Set;for await(const iter of value)switch(iter.type){case"number":case"string":case"boolean":case"datetime":added.has(iter.data)||(added.add(iter.data),yield iter);break;default:yield iter}})):NULL_VALUE},array.unique.arity=1;const pt={text:async function(args,scope,execute){const value=await execute(args[0],scope),text=await portableTextContent(value);return null===text?NULL_VALUE:fromString(text)}};pt.text.arity=1;const sanity={projectId:async function(args,scope){return scope.context.sanity?fromString(scope.context.sanity.projectId):NULL_VALUE},dataset:async function(args,scope){return scope.context.sanity?fromString(scope.context.sanity.dataset):NULL_VALUE}},pipeFunctions={order:async function order(base,args,scope,execute){if(await!0,!base.isArray())return NULL_VALUE;const mappers=[],directions=[];let n=0;for(let mapper of args){let direction="asc";"Desc"===mapper.type?(direction="desc",mapper=mapper.base):"Asc"===mapper.type&&(mapper=mapper.base),mappers.push(mapper),directions.push(direction),n++}const aux=[];let idx=0;for await(const value of base){const newScope=scope.createNested(value),tuple=[await value.get(),idx];for(let i=0;i<n;i++){const result=await execute(mappers[i],newScope);tuple.push(await result.get())}aux.push(tuple),idx++}return aux.sort(((aTuple,bTuple)=>{for(let i=0;i<n;i++){let c=totalCompare(aTuple[i+2],bTuple[i+2]);if("desc"===directions[i]&&(c=-c),0!==c)return c}return aTuple[1]-bTuple[1]})),fromJS(aux.map((v=>v[0])))}};pipeFunctions.order.arity=count2=>count2>=1,pipeFunctions.score=async function score(base,args,scope,execute){if(!base.isArray())return NULL_VALUE;const unknown=[],scored=[];for await(const value of base){if("object"!==value.type){unknown.push(await value.get());continue}const newScope=scope.createNested(value);let valueScore="number"==typeof value.data._score?value.data._score:0;for(const arg of args)valueScore+=await evaluateScore(arg,newScope,execute);const newObject=Object.assign({},value.data,{_score:valueScore});scored.push(newObject)}return scored.sort(((a,b)=>b._score-a._score)),fromJS(scored)},pipeFunctions.score.arity=count2=>count2>=1;const delta={operation:async function(args,scope){const hasBefore=null!==scope.context.before,hasAfter=null!==scope.context.after;return hasBefore&&hasAfter?fromString("update"):hasAfter?fromString("create"):hasBefore?fromString("delete"):NULL_VALUE},changedAny:()=>{throw new Error("not implemented")}};delta.changedAny.arity=1,delta.changedAny.mode="delta",delta.changedOnly=()=>{throw new Error("not implemented")},delta.changedOnly.arity=1,delta.changedOnly.mode="delta";const diff={changedAny:()=>{throw new Error("not implemented")}};diff.changedAny.arity=3,diff.changedOnly=()=>{throw new Error("not implemented")},diff.changedOnly.arity=3;const math={min:async function(args,scope,execute){const arr=await execute(args[0],scope);if(!arr.isArray())return NULL_VALUE;let n;for await(const elem of arr)if("null"!==elem.type){if("number"!==elem.type)return NULL_VALUE;(void 0===n||elem.data<n)&&(n=elem.data)}return fromJS(n)}};math.min.arity=1,math.max=async function(args,scope,execute){const arr=await execute(args[0],scope);if(!arr.isArray())return NULL_VALUE;let n;for await(const elem of arr)if("null"!==elem.type){if("number"!==elem.type)return NULL_VALUE;(void 0===n||elem.data>n)&&(n=elem.data)}return fromJS(n)},math.max.arity=1,math.sum=async function(args,scope,execute){const arr=await execute(args[0],scope);if(!arr.isArray())return NULL_VALUE;let n=0;for await(const elem of arr)if("null"!==elem.type){if("number"!==elem.type)return NULL_VALUE;n+=elem.data}return fromJS(n)},math.sum.arity=1,math.avg=async function(args,scope,execute){const arr=await execute(args[0],scope);if(!arr.isArray())return NULL_VALUE;let n=0,c=0;for await(const elem of arr)if("null"!==elem.type){if("number"!==elem.type)return NULL_VALUE;n+=elem.data,c++}return 0===c?NULL_VALUE:fromJS(n/c)},math.avg.arity=1;const namespaces={global:_global,string:string2,array,pt,delta,diff,sanity,math};class MarkProcessor{constructor(string,marks,parseOptions){this.allowBoost=!1,this.string=string,this.marks=marks,this.index=0,this.parseOptions=parseOptions}hasMark(){let pos=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.index+pos<this.marks.length}getMark(){let pos=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.marks[this.index+pos]}shift(){this.index+=1}process(visitor){const mark=this.marks[this.index];this.shift();const func=visitor[mark.name];if(!func)throw new Error("Unknown handler: ".concat(mark.name));return func.call(visitor,this,mark)}processString(){return this.shift(),this.processStringEnd()}processStringEnd(){const prev=this.marks[this.index-1],curr=this.marks[this.index];return this.shift(),this.string.slice(prev.position,curr.position)}slice(len){const pos=this.marks[this.index].position;return this.string.slice(pos,pos+len)}}const WS=/^([\t\n\v\f\r \u0085\u00A0]|(\/\/[^\n]*\n))+/,NUM=/^\d+/,IDENT=/^[a-zA-Z_][a-zA-Z_0-9]*/,PREC_PAIR=1,PREC_OR=2,PREC_AND=3,PREC_COMP=4,PREC_ORDER=4,PREC_ADD=6,PREC_SUB=6,PREC_MUL=7,PREC_DIV=7,PREC_MOD=7,PREC_POW=8,PREC_POS=10,PREC_NOT=10,PREC_NEG=8;function parseExpr(str,pos,level){let marks,startPos=pos;switch(str[pos]){case"+":{let rhs=parseExpr(str,skipWS(str,pos+1),PREC_POS);if("error"===rhs.type)return rhs;marks=[{name:"pos",position:startPos}].concat(rhs.marks),pos=rhs.position;break}case"-":{let rhs=parseExpr(str,skipWS(str,pos+1),PREC_NEG);if("error"===rhs.type)return rhs;marks=[{name:"neg",position:startPos}].concat(rhs.marks),pos=rhs.position;break}case"(":{let rhs=parseExpr(str,skipWS(str,pos+1),0);if("error"===rhs.type)return rhs;switch(str[pos=skipWS(str,rhs.position)]){case",":for(marks=[{name:"tuple",position:startPos}].concat(rhs.marks),pos=skipWS(str,pos+1);;){if(rhs=parseExpr(str,pos,0),"error"===rhs.type)return rhs;if(","!==str[pos=skipWS(str,rhs.position)])break;pos=skipWS(str,pos+1)}if(")"!==str[pos])return{type:"error",position:pos};pos++,marks.push({name:"tuple_end",position:pos});break;case")":pos++,marks=[{name:"group",position:startPos}].concat(rhs.marks);break;default:return{type:"error",position:pos}}break}case"!":{let rhs=parseExpr(str,skipWS(str,pos+1),PREC_NOT);if("error"===rhs.type)return rhs;marks=[{name:"not",position:startPos}].concat(rhs.marks),pos=rhs.position;break}case"{":{let result=parseObject(str,pos);if("error"===result.type)return result;marks=result.marks,pos=result.position;break}case"[":if(marks=[{name:"array",position:pos}],"]"!==str[pos=skipWS(str,pos+1)])for(;;){"..."===str.slice(pos,pos+3)&&(marks.push({name:"array_splat",position:pos}),pos=skipWS(str,pos+3));let res=parseExpr(str,pos,0);if("error"===res.type)return res;if(marks=marks.concat(res.marks),","!==str[pos=skipWS(str,pos=res.position)])break;if("]"===str[pos=skipWS(str,pos+1)])break}if("]"!==str[pos])return{type:"error",position:pos};pos++,marks.push({name:"array_end",position:pos});break;case"'":case'"':{let result=function parseString(str,pos){let token=str[pos];pos+=1;const marks=[{name:"str",position:pos}];str:for(;;pos++){if(pos>str.length)return{type:"error",position:pos};switch(str[pos]){case token:marks.push({name:"str_end",position:pos}),pos++;break str;case"\\":marks.push({name:"str_pause",position:pos}),"u"===str[pos+1]?"{"===str[pos+2]?(marks.push({name:"unicode_hex",position:pos+3}),pos=str.indexOf("}",pos+3),marks.push({name:"unicode_hex_end",position:pos})):(marks.push({name:"unicode_hex",position:pos+2}),marks.push({name:"unicode_hex_end",position:pos+6}),pos+=5):(marks.push({name:"single_escape",position:pos+1}),pos+=1),marks.push({name:"str_start",position:pos+1})}}return{type:"success",marks,position:pos}}(str,pos);if("error"===result.type)return result;marks=result.marks,pos=result.position;break}case"^":for(pos++,marks=[];"."===str[pos]&&"^"===str[pos+1];)marks.push({name:"dblparent",position:startPos}),pos+=2;marks.push({name:"parent",position:startPos});break;case"@":marks=[{name:"this",position:startPos}],pos++;break;case"*":marks=[{name:"everything",position:startPos}],pos++;break;case"$":{let identLen=parseRegex(str,pos+1,IDENT);identLen&&(marks=[{name:"param",position:startPos},{name:"ident",position:startPos+1},{name:"ident_end",position:pos+=1+identLen}]);break}default:{let numLen=parseRegex(str,pos,NUM);if(numLen){let name="integer";if("."===str[pos+=numLen]){let fracLen=parseRegex(str,pos+1,NUM);fracLen&&(name="float",pos+=1+fracLen)}if("e"===str[pos]||"E"===str[pos]){name="sci","+"!==str[++pos]&&"-"!==str[pos]||pos++;let expLen=parseRegex(str,pos,NUM);if(!expLen)return{type:"error",position:pos};pos+=expLen}marks=[{name,position:startPos},{name:name+"_end",position:pos}];break}let identLen=parseRegex(str,pos,IDENT);if(identLen){switch(str[pos+=identLen]){case":":case"(":{let result=parseFuncCall(str,startPos,pos);if("error"===result.type)return result;marks=result.marks,pos=result.position;break}default:marks=[{name:"this_attr",position:startPos},{name:"ident",position:startPos},{name:"ident_end",position:pos}]}break}}}if(!marks)return{type:"error",position:pos};let trav,lhsLevel=12;loop:for(;;){let innerPos=skipWS(str,pos);if(innerPos===str.length){pos=innerPos;break}if(trav=parseTraversal(str,innerPos),"success"!==trav.type)switch(str[innerPos]){case"=":switch(str[innerPos+1]){case">":{if(level>PREC_PAIR||lhsLevel<=PREC_PAIR)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+2),PREC_PAIR);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"pair",position:startPos}),pos=rhs.position,lhsLevel=PREC_PAIR;break}case"=":{if(level>PREC_COMP||lhsLevel<=PREC_COMP)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+2),5);if("error"===rhs.type)return rhs;marks.unshift({name:"comp",position:startPos}),marks.push({name:"op",position:innerPos},{name:"op_end",position:innerPos+2}),marks=marks.concat(rhs.marks),pos=rhs.position,lhsLevel=PREC_COMP;break}default:break loop}break;case"+":{if(level>PREC_ADD||lhsLevel<PREC_ADD)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+1),PREC_ADD+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"add",position:startPos}),pos=rhs.position,lhsLevel=PREC_ADD;break}case"-":{if(level>PREC_SUB||lhsLevel<PREC_SUB)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+1),PREC_SUB+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"sub",position:startPos}),pos=rhs.position,lhsLevel=PREC_SUB;break}case"*":{if("*"===str[innerPos+1]){if(level>PREC_POW||lhsLevel<=PREC_POW)break loop;let rhs2=parseExpr(str,skipWS(str,innerPos+2),PREC_POW);if("error"===rhs2.type)return rhs2;marks=marks.concat(rhs2.marks),marks.unshift({name:"pow",position:startPos}),pos=rhs2.position,lhsLevel=PREC_POW;break}if(level>PREC_MUL||lhsLevel<PREC_MUL)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+1),PREC_MUL+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"mul",position:startPos}),pos=rhs.position,lhsLevel=PREC_MUL;break}case"/":{if(level>PREC_DIV||lhsLevel<PREC_DIV)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+1),PREC_DIV+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"div",position:startPos}),pos=rhs.position,lhsLevel=PREC_DIV;break}case"%":{if(level>PREC_MOD||lhsLevel<PREC_MOD)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+1),PREC_MOD+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"mod",position:startPos}),pos=rhs.position,lhsLevel=PREC_MOD;break}case"<":case">":{if(level>PREC_COMP||lhsLevel<=PREC_COMP)break loop;let nextPos=innerPos+1;"="===str[nextPos]&&nextPos++;let rhs=parseExpr(str,skipWS(str,nextPos),PREC_COMP+1);if("error"===rhs.type)return rhs;marks.unshift({name:"comp",position:startPos}),marks.push({name:"op",position:innerPos},{name:"op_end",position:nextPos}),marks=marks.concat(rhs.marks),pos=rhs.position,lhsLevel=PREC_COMP;break}case"|":if("|"===str[innerPos+1]){if(level>PREC_OR||lhsLevel<PREC_OR)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+2),PREC_OR+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"or",position:startPos}),pos=rhs.position,lhsLevel=PREC_OR}else{if(level>11||lhsLevel<11)break loop;let identPos=skipWS(str,innerPos+1),identLen=parseRegex(str,identPos,IDENT);if(!identLen)return{type:"error",position:identPos};if("("===str[pos=identPos+identLen]||":"===str[pos]){let result=parseFuncCall(str,identPos,pos);if("error"===result.type)return result;marks=marks.concat(result.marks),marks.unshift({name:"pipecall",position:startPos}),pos=result.position,lhsLevel=11}}break;case"&":{if("&"!=str[innerPos+1])break loop;if(level>PREC_AND||lhsLevel<PREC_AND)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+2),PREC_AND+1);if("error"===rhs.type)return rhs;marks=marks.concat(rhs.marks),marks.unshift({name:"and",position:startPos}),pos=rhs.position,lhsLevel=PREC_AND;break}case"!":{if("="!==str[innerPos+1])break loop;if(level>PREC_COMP||lhsLevel<PREC_COMP)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+2),PREC_COMP+1);if("error"===rhs.type)return rhs;marks.unshift({name:"comp",position:startPos}),marks.push({name:"op",position:innerPos},{name:"op_end",position:innerPos+2}),marks=marks.concat(rhs.marks),pos=rhs.position,lhsLevel=PREC_COMP;break}case"d":if("desc"!==str.slice(innerPos,innerPos+4))break loop;if(level>PREC_ORDER||lhsLevel<PREC_ORDER)break loop;marks.unshift({name:"desc",position:startPos}),pos=innerPos+4,lhsLevel=PREC_ORDER;break;case"a":if("asc"!==str.slice(innerPos,innerPos+3))break loop;if(level>PREC_ORDER||lhsLevel<PREC_ORDER)break loop;marks.unshift({name:"asc",position:startPos}),pos=innerPos+3,lhsLevel=PREC_ORDER;break;default:switch(parseRegexStr(str,innerPos,IDENT)){case"in":{if(level>PREC_COMP||lhsLevel<=PREC_COMP)break loop;let isGroup=!1;"("===str[pos=skipWS(str,innerPos+2)]&&(isGroup=!0,pos=skipWS(str,pos+1));let rangePos=pos,result=parseExpr(str,pos,PREC_COMP+1);if("error"===result.type)return result;if("."===str[pos=skipWS(str,result.position)]&&"."===str[pos+1]){let type="inc_range";"."===str[pos+2]?(type="exc_range",pos=skipWS(str,pos+3)):pos=skipWS(str,pos+2);let rhs=parseExpr(str,pos,PREC_COMP+1);if("error"===rhs.type)return rhs;marks.unshift({name:"in_range",position:startPos}),marks=marks.concat({name:type,position:rangePos},result.marks,rhs.marks),pos=rhs.position}else marks.unshift({name:"comp",position:startPos}),marks.push({name:"op",position:innerPos},{name:"op_end",position:innerPos+2}),marks=marks.concat(result.marks);if(isGroup){if(")"!==str[pos=skipWS(str,pos)])return{type:"error",position:pos};pos++}lhsLevel=PREC_COMP;break}case"match":{if(level>PREC_COMP||lhsLevel<=PREC_COMP)break loop;let rhs=parseExpr(str,skipWS(str,innerPos+5),PREC_COMP+1);if("error"===rhs.type)return rhs;marks.unshift({name:"comp",position:startPos}),marks.push({name:"op",position:innerPos},{name:"op_end",position:innerPos+5}),marks=marks.concat(rhs.marks),pos=rhs.position,lhsLevel=4;break}default:break loop}}else{for(marks.unshift({name:"traverse",position:startPos});"success"===trav.type;)marks=marks.concat(trav.marks),trav=parseTraversal(str,skipWS(str,pos=trav.position));marks.push({name:"traversal_end",position:pos})}}return{type:"success",marks,position:pos,failPosition:"error"===(null==trav?void 0:trav.type)&&trav.position}}function parseTraversal(str,pos){let startPos=pos;switch(str[pos]){case".":{let identStart=pos=skipWS(str,pos+1),identLen2=parseRegex(str,pos,IDENT);return identLen2?{type:"success",marks:[{name:"attr_access",position:startPos},{name:"ident",position:identStart},{name:"ident_end",position:pos+=identLen2}],position:pos}:{type:"error",position:pos}}case"-":if(">"!==str[pos+1])return{type:"error",position:pos};let marks=[{name:"deref",position:startPos}],identPos=skipWS(str,pos+=2),identLen=parseRegex(str,identPos,IDENT);return identLen&&(pos=identPos+identLen,marks.push({name:"deref_attr",position:identPos},{name:"ident",position:identPos},{name:"ident_end",position:pos})),{type:"success",marks,position:pos};case"[":{if("]"===str[pos=skipWS(str,pos+1)])return{type:"success",marks:[{name:"array_postfix",position:startPos}],position:pos+1};let rangePos=pos,result=parseExpr(str,pos,0);if("error"===result.type)return result;if("."===str[pos=skipWS(str,result.position)]&&"."===str[pos+1]){let type="inc_range";"."===str[pos+2]?(type="exc_range",pos+=3):pos+=2;let rhs=parseExpr(str,pos=skipWS(str,pos),0);return"error"===rhs.type?rhs:"]"!==str[pos=skipWS(str,rhs.position)]?{type:"error",position:pos}:{type:"success",marks:[{name:"slice",position:startPos},{name:type,position:rangePos}].concat(result.marks,rhs.marks),position:pos+1}}return"]"!==str[pos]?{type:"error",position:pos}:{type:"success",marks:[{name:"square_bracket",position:startPos}].concat(result.marks),position:pos+1}}case"|":if("{"===str[pos=skipWS(str,pos+1)]){let result=parseObject(str,pos);return"error"===result.type||result.marks.unshift({name:"projection",position:startPos}),result}break;case"{":{let result=parseObject(str,pos);return"error"===result.type||result.marks.unshift({name:"projection",position:startPos}),result}}return{type:"error",position:pos}}function parseFuncCall(str,startPos,pos){let marks=[];if(marks.push({name:"func_call",position:startPos}),":"===str[pos]&&":"===str[pos+1]){marks.push({name:"namespace",position:startPos}),marks.push({name:"ident",position:startPos},{name:"ident_end",position:pos});let nameLen=parseRegex(str,pos=skipWS(str,pos+2),IDENT);if(!nameLen)return{type:"error",position:pos};if(marks.push({name:"ident",position:pos},{name:"ident_end",position:pos+nameLen}),"("!==str[pos=skipWS(str,pos+nameLen)])return{type:"error",position:pos};pos=skipWS(str,++pos)}else marks.push({name:"ident",position:startPos},{name:"ident_end",position:pos}),pos=skipWS(str,pos+1);let lastPos=pos;if(")"!==str[pos])for(;;){let result=parseExpr(str,pos,0);if("error"===result.type)return result;if(marks=marks.concat(result.marks),lastPos=result.position,","!==str[pos=skipWS(str,result.position)])break;if(")"===str[pos=skipWS(str,pos+1)])break}return")"!==str[pos]?{type:"error",position:pos}:(marks.push({name:"func_args_end",position:lastPos}),{type:"success",marks,position:pos+1})}function parseObject(str,pos){let marks=[{name:"object",position:pos}];for(pos=skipWS(str,pos+1);"}"!==str[pos];){let pairPos=pos;if("..."===str.slice(pos,pos+3))if("}"!==str[pos=skipWS(str,pos+3)]&&","!==str[pos]){let expr=parseExpr(str,pos,0);if("error"===expr.type)return expr;marks.push({name:"object_splat",position:pairPos}),marks=marks.concat(expr.marks),pos=expr.position}else marks.push({name:"object_splat_this",position:pairPos});else{let expr=parseExpr(str,pos,0);if("error"===expr.type)return expr;let nextPos=skipWS(str,expr.position);if("str"===expr.marks[0].name&&":"===str[nextPos]){let value=parseExpr(str,skipWS(str,nextPos+1),0);if("error"===value.type)return value;marks.push({name:"object_pair",position:pairPos}),marks=marks.concat(expr.marks,value.marks),pos=value.position}else marks=marks.concat({name:"object_expr",position:pos},expr.marks),pos=expr.position}if(","!==str[pos=skipWS(str,pos)])break;pos=skipWS(str,pos+1)}return"}"!==str[pos]?{type:"error",position:pos}:(pos++,marks.push({name:"object_end",position:pos}),{type:"success",marks,position:pos})}function skipWS(str,pos){return pos+parseRegex(str,pos,WS)}function parseRegex(str,pos,re){let m=re.exec(str.slice(pos));return m?m[0].length:0}function parseRegexStr(str,pos,re){let m=re.exec(str.slice(pos));return m?m[0]:null}function join(a,b){return base=>b(a(base))}function map(inner){return base=>({type:"Map",base,expr:inner({type:"This"})})}function traverseArray(build,right){if(!right)return{type:"a-a",build};switch(right.type){case"a-a":return{type:"a-a",build:join(build,right.build)};case"a-b":return{type:"a-b",build:join(build,right.build)};case"b-b":return{type:"a-a",build:join(build,map(right.build))};case"b-a":return{type:"a-a",build:join(build,(inner=right.build,base=>({type:"FlatMap",base,expr:inner({type:"This"})})))};default:throw new Error("unknown type: ".concat(right.type))}var inner}function traversePlain(mapper,right){if(!right)return{type:"b-b",build:mapper};switch(right.type){case"a-a":case"b-a":return{type:"b-a",build:join(mapper,right.build)};case"a-b":case"b-b":return{type:"b-b",build:join(mapper,right.build)};default:throw new Error("unknown type: ".concat(right.type))}}const ESCAPE_SEQUENCE={"'":"'",'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function expandHex(str){const charCode=parseInt(str,16);return String.fromCharCode(charCode)}class GroqQueryError extends Error{constructor(){super(...arguments),this.name="GroqQueryError"}}const EXPR_BUILDER={group:p=>({type:"Group",base:p.process(EXPR_BUILDER)}),everything:()=>({type:"Everything"}),this:()=>({type:"This"}),parent:()=>({type:"Parent",n:1}),dblparent:p=>({type:"Parent",n:p.process(EXPR_BUILDER).n+1}),traverse(p){const base=p.process(EXPR_BUILDER),traversalList=[];for(;"traversal_end"!==p.getMark().name;)traversalList.push(p.process(TRAVERSE_BUILDER));p.shift();let traversal=null;for(let i=traversalList.length-1;i>=0;i--)traversal=traversalList[i](traversal);if("Everything"!==base.type&&"Array"!==base.type&&"PipeFuncCall"!==base.type||(traversal=traverseArray((val=>val),traversal)),null===traversal)throw new Error("BUG: unexpected empty traversal");return traversal.build(base)},this_attr(p){const name=p.processString();return"null"===name?{type:"Value",value:null}:"true"===name?{type:"Value",value:!0}:"false"===name?{type:"Value",value:!1}:{type:"AccessAttribute",name}},neg:p=>({type:"Neg",base:p.process(EXPR_BUILDER)}),pos:p=>({type:"Pos",base:p.process(EXPR_BUILDER)}),add:p=>({type:"OpCall",op:"+",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),sub:p=>({type:"OpCall",op:"-",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),mul:p=>({type:"OpCall",op:"*",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),div:p=>({type:"OpCall",op:"/",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),mod:p=>({type:"OpCall",op:"%",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),pow:p=>({type:"OpCall",op:"**",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),comp(p){const left=p.process(EXPR_BUILDER);return{type:"OpCall",op:p.processString(),left,right:p.process(EXPR_BUILDER)}},in_range(p){const base=p.process(EXPR_BUILDER),isInclusive="inc_range"===p.getMark().name;p.shift();return{type:"InRange",base,left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER),isInclusive}},str(p){let value="";loop:for(;p.hasMark();){const mark=p.getMark();switch(mark.name){case"str_end":value+=p.processStringEnd();break loop;case"str_pause":value+=p.processStringEnd();break;case"str_start":p.shift();break;case"single_escape":{const char=p.slice(1);p.shift(),value+=ESCAPE_SEQUENCE[char];break}case"unicode_hex":p.shift(),value+=expandHex(p.processStringEnd());break;default:throw new Error("unexpected mark: ".concat(mark.name))}}return{type:"Value",value}},integer(p){const strValue=p.processStringEnd();return{type:"Value",value:Number(strValue)}},float(p){const strValue=p.processStringEnd();return{type:"Value",value:Number(strValue)}},sci(p){const strValue=p.processStringEnd();return{type:"Value",value:Number(strValue)}},object(p){const attributes=[];for(;"object_end"!==p.getMark().name;)attributes.push(p.process(OBJECT_BUILDER));return p.shift(),{type:"Object",attributes}},array(p){const elements=[];for(;"array_end"!==p.getMark().name;){let isSplat=!1;"array_splat"===p.getMark().name&&(isSplat=!0,p.shift());const value=p.process(EXPR_BUILDER);elements.push({type:"ArrayElement",value,isSplat})}return p.shift(),{type:"Array",elements}},tuple(p){const members=[];for(;"tuple_end"!==p.getMark().name;)members.push(p.process(EXPR_BUILDER));return p.shift(),{type:"Tuple",members}},func_call(p){let namespace="global";"namespace"===p.getMark().name&&(p.shift(),namespace=p.processString());const name=p.processString();if("global"===namespace&&"select"===name){const result={type:"Select",alternatives:[]};for(;"func_args_end"!==p.getMark().name;)if("pair"===p.getMark().name){if(result.fallback)throw new GroqQueryError("unexpected argument to select()");p.shift();const condition=p.process(EXPR_BUILDER),value=p.process(EXPR_BUILDER);result.alternatives.push({type:"SelectAlternative",condition,value})}else{if(result.fallback)throw new GroqQueryError("unexpected argument to select()");const value=p.process(EXPR_BUILDER);result.fallback=value}return p.shift(),result}const args=[];for(;"func_args_end"!==p.getMark().name;)argumentShouldBeSelector(namespace,name,args.length)?(p.process(SELECTOR_BUILDER),args.push({type:"Selector"})):args.push(p.process(EXPR_BUILDER));if(p.shift(),"global"===namespace&&("before"===name||"after"===name)&&"delta"===p.parseOptions.mode)return{type:"Context",key:name};if("global"===namespace&&"boost"===name&&!p.allowBoost)throw new GroqQueryError("unexpected boost");const funcs=namespaces[namespace];if(!funcs)throw new GroqQueryError("Undefined namespace: ".concat(namespace));const func=funcs[name];if(!func)throw new GroqQueryError("Undefined function: ".concat(name));if(void 0!==func.arity&&validateArity(name,func.arity,args.length),void 0!==func.mode&&func.mode!==p.parseOptions.mode)throw new GroqQueryError("Undefined function: ".concat(name));return{type:"FuncCall",func,name,args}},pipecall(p){const base=p.process(EXPR_BUILDER);p.shift();let namespace="global";if("namespace"===p.getMark().name&&(p.shift(),namespace=p.processString()),"global"!==namespace)throw new GroqQueryError("Undefined namespace: ".concat(namespace));const name=p.processString(),args=[],oldAllowBoost=p.allowBoost;for("score"===name&&(p.allowBoost=!0);;){const markName=p.getMark().name;if("func_args_end"===markName)break;if("order"===name){if("asc"===markName){p.shift(),args.push({type:"Asc",base:p.process(EXPR_BUILDER)});continue}if("desc"===markName){p.shift(),args.push({type:"Desc",base:p.process(EXPR_BUILDER)});continue}}args.push(p.process(EXPR_BUILDER))}p.shift(),p.allowBoost=oldAllowBoost;const func=pipeFunctions[name];if(!func)throw new GroqQueryError("Undefined pipe function: ".concat(name));return func.arity&&validateArity(name,func.arity,args.length),{type:"PipeFuncCall",func,base,name,args}},pair(p){throw new GroqQueryError("unexpected =>")},and:p=>({type:"And",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),or:p=>({type:"Or",left:p.process(EXPR_BUILDER),right:p.process(EXPR_BUILDER)}),not:p=>({type:"Not",base:p.process(EXPR_BUILDER)}),asc(p){throw new GroqQueryError("unexpected asc")},desc(p){throw new GroqQueryError("unexpected desc")},param(p){const name=p.processString();return p.parseOptions.params&&p.parseOptions.params.hasOwnProperty(name)?{type:"Value",value:p.parseOptions.params[name]}:{type:"Parameter",name}}},OBJECT_BUILDER={object_expr(p){if("pair"===p.getMark().name){p.shift();return{type:"ObjectConditionalSplat",condition:p.process(EXPR_BUILDER),value:p.process(EXPR_BUILDER)}}const value=p.process(EXPR_BUILDER);return{type:"ObjectAttributeValue",name:extractPropertyKey(value),value}},object_pair(p){const name=p.process(EXPR_BUILDER);if("Value"!==name.type)throw new Error("name must be string");const value=p.process(EXPR_BUILDER);return{type:"ObjectAttributeValue",name:name.value,value}},object_splat:p=>({type:"ObjectSplat",value:p.process(EXPR_BUILDER)}),object_splat_this:()=>({type:"ObjectSplat",value:{type:"This"}})},TRAVERSE_BUILDER={square_bracket(p){const expr=p.process(EXPR_BUILDER),value=tryConstantEvaluate(expr);return value&&"number"===value.type?right=>function traverseElement(mapper,right){if(!right)return{type:"a-b",build:mapper};switch(right.type){case"a-a":case"b-a":return{type:"a-a",build:join(mapper,right.build)};case"a-b":case"b-b":return{type:"a-b",build:join(mapper,right.build)};default:throw new Error("unknown type: ".concat(right.type))}}((base=>({type:"AccessElement",base,index:value.data})),right):value&&"string"===value.type?right=>traversePlain((base=>({type:"AccessAttribute",base,name:value.data})),right):right=>traverseArray((base=>({type:"Filter",base,expr})),right)},slice(p){const isInclusive="inc_range"===p.getMark().name;p.shift();const left=p.process(EXPR_BUILDER),right=p.process(EXPR_BUILDER),leftValue=tryConstantEvaluate(left),rightValue=tryConstantEvaluate(right);if(!leftValue||!rightValue||"number"!==leftValue.type||"number"!==rightValue.type)throw new GroqQueryError("slicing must use constant numbers");return rhs=>traverseArray((base=>({type:"Slice",base,left:leftValue.data,right:rightValue.data,isInclusive})),rhs)},projection(p){const obj=p.process(EXPR_BUILDER);return right=>function traverseProjection(mapper,right){if(!right)return{type:"b-b",build:mapper};switch(right.type){case"a-a":return{type:"a-a",build:join(map(mapper),right.build)};case"a-b":return{type:"a-b",build:join(map(mapper),right.build)};case"b-a":return{type:"b-a",build:join(mapper,right.build)};case"b-b":return{type:"b-b",build:join(mapper,right.build)};default:throw new Error("unknown type: ".concat(right.type))}}((base=>({type:"Projection",base,expr:obj})),right)},attr_access(p){const name=p.processString();return right=>traversePlain((base=>({type:"AccessAttribute",base,name})),right)},deref(p){let attr=null;"deref_attr"===p.getMark().name&&(p.shift(),attr=p.processString());return right=>traversePlain((base=>(base=>attr?{type:"AccessAttribute",base,name:attr}:base)({type:"Deref",base})),right)},array_postfix:p=>right=>traverseArray((base=>({type:"ArrayCoerce",base})),right)},SELECTOR_BUILDER={group:p=>(p.process(SELECTOR_BUILDER),null),everything(){throw new Error("Invalid selector syntax")},this(){throw new Error("Invalid selector syntax")},parent(){throw new Error("Invalid selector syntax")},dblparent(p){throw new Error("Invalid selector syntax")},traverse(p){for(p.process(SELECTOR_BUILDER);"traversal_end"!==p.getMark().name;)p.process(TRAVERSE_BUILDER);return p.shift(),null},this_attr:p=>(p.processString(),null),neg(p){throw new Error("Invalid selector syntax")},pos(p){throw new Error("Invalid selector syntax")},add(p){throw new Error("Invalid selector syntax")},sub(p){throw new Error("Invalid selector syntax")},mul(p){throw new Error("Invalid selector syntax")},div(p){throw new Error("Invalid selector syntax")},mod(p){throw new Error("Invalid selector syntax")},pow(p){throw new Error("Invalid selector syntax")},comp(p){throw new Error("Invalid selector syntax")},in_range(p){throw new Error("Invalid selector syntax")},str(p){throw new Error("Invalid selector syntax")},integer(p){throw new Error("Invalid selector syntax")},float(p){throw new Error("Invalid selector syntax")},sci(p){throw new Error("Invalid selector syntax")},object(p){throw new Error("Invalid selector syntax")},array(p){throw new Error("Invalid selector syntax")},tuple(p){throw new Error("Invalid selector syntax")},func_call(p,mark){const func=EXPR_BUILDER.func_call(p,mark);if("anywhere"===func.name&&1===func.args.length)return null;throw new Error("Invalid selector syntax")},pipecall(p){throw new Error("Invalid selector syntax")},pair(p){throw new Error("Invalid selector syntax")},and(p){throw new Error("Invalid selector syntax")},or(p){throw new Error("Invalid selector syntax")},not(p){throw new Error("Invalid selector syntax")},asc(p){throw new Error("Invalid selector syntax")},desc(p){throw new Error("Invalid selector syntax")},param(p){throw new Error("Invalid selector syntax")}};function extractPropertyKey(node){if("AccessAttribute"===node.type&&!node.base)return node.name;if("Deref"===node.type||"Map"===node.type||"Projection"===node.type||"Slice"===node.type||"Filter"===node.type||"AccessElement"===node.type||"ArrayCoerce"===node.type)return extractPropertyKey(node.base);throw new GroqQueryError("Cannot determine property key for type: ".concat(node.type))}function validateArity(name,arity,count){if("number"==typeof arity){if(count!==arity)throw new GroqQueryError("Incorrect number of arguments to function ".concat(name,"(). Expected ").concat(arity,", got ").concat(count,"."))}else if(arity&&!arity(count))throw new GroqQueryError("Incorrect number of arguments to function ".concat(name,"()."))}function argumentShouldBeSelector(namespace,functionName,argCount){return"diff"==namespace&&2==argCount&&["changedAny","changedOnly"].includes(functionName)}class GroqSyntaxError extends Error{constructor(position){super("Syntax error in GROQ query at position ".concat(position)),this.name="GroqSyntaxError",this.position=position}}function parse(input){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const result=function parse$1(str){let pos=0;pos=skipWS(str,pos);let result=parseExpr(str,pos,0);return"error"===result.type?result:(pos=skipWS(str,result.position),pos!==str.length?(result.failPosition&&(pos=result.failPosition-1),{type:"error",position:pos}):(delete result.position,delete result.failPosition,result))}(input);if("error"===result.type)throw new GroqSyntaxError(result.position);return new MarkProcessor(input,result.marks,options).process(EXPR_BUILDER)}var OPS=["Value","Copy","Blank","ReturnIntoArray","ReturnIntoObject","ReturnIntoObjectSameKey","PushField","PushElement","PushParent","Pop","PushFieldCopy","PushFieldBlank","PushElementCopy","PushElementBlank","ReturnIntoObjectPop","ReturnIntoObjectSameKeyPop","ReturnIntoArrayPop","ObjectSetFieldValue","ObjectCopyField","ObjectDeleteField","ArrayAppendValue","ArrayAppendSlice","StringAppendString","StringAppendSlice"],Patcher=function(){function Patcher(model,root,patch){this.i=0,this.inputStack=[],this.outputStack=[],this.model=model,this.root=root,this.patch=patch}return Patcher.prototype.read=function(){return this.patch[this.i++]},Patcher.prototype.process=function(){for(this.inputStack.push({value:this.root}),this.outputStack.push({value:this.root});this.i<this.patch.length;){var opcode=this.read(),op=OPS[opcode];if(!op)throw new Error("Unknown opcode: "+opcode);this["process"+op].apply(this)}var entry=this.outputStack.pop();return this.finalizeOutput(entry)},Patcher.prototype.inputEntry=function(){return this.inputStack[this.inputStack.length-1]},Patcher.prototype.inputKey=function(entry,idx){return entry.keys||(entry.keys=this.model.objectGetKeys(entry.value).sort()),entry.keys[idx]},Patcher.prototype.outputEntry=function(){return this.outputStack[this.outputStack.length-1]},Patcher.prototype.outputArray=function(){var entry=this.outputEntry();return entry.writeValue||(entry.writeValue=this.model.copyArray(entry.value)),entry.writeValue},Patcher.prototype.outputObject=function(){var entry=this.outputEntry();return entry.writeValue||(entry.writeValue=this.model.copyObject(entry.value)),entry.writeValue},Patcher.prototype.outputString=function(){var entry=this.outputEntry();return entry.writeValue||(entry.writeValue=this.model.copyString(entry.value)),entry.writeValue},Patcher.prototype.finalizeOutput=function(entry){return entry.writeValue?this.model.finalize(entry.writeValue):entry.value},Patcher.prototype.processValue=function(){var value=this.model.wrap(this.read());this.outputStack.push({value})},Patcher.prototype.processCopy=function(){var input=this.inputEntry();this.outputStack.push({value:input.value})},Patcher.prototype.processBlank=function(){this.outputStack.push({value:null})},Patcher.prototype.processReturnIntoArray=function(){var entry=this.outputStack.pop(),result=this.finalizeOutput(entry),arr=this.outputArray();this.model.arrayAppendValue(arr,result)},Patcher.prototype.processReturnIntoObject=function(){var key=this.read(),entry=this.outputStack.pop(),result=this.finalizeOutput(entry);result=this.model.markChanged(result);var obj=this.outputObject();this.model.objectSetField(obj,key,result)},Patcher.prototype.processReturnIntoObjectSameKey=function(){var input=this.inputEntry(),entry=this.outputStack.pop(),result=this.finalizeOutput(entry),obj=this.outputObject();this.model.objectSetField(obj,input.key,result)},Patcher.prototype.processPushField=function(){var idx=this.read(),entry=this.inputEntry(),key=this.inputKey(entry,idx),value=this.model.objectGetField(entry.value,key);this.inputStack.push({value,key})},Patcher.prototype.processPushElement=function(){var idx=this.read(),entry=this.inputEntry(),value=this.model.arrayGetElement(entry.value,idx);this.inputStack.push({value})},Patcher.prototype.processPop=function(){this.inputStack.pop()},Patcher.prototype.processPushFieldCopy=function(){this.processPushField(),this.processCopy()},Patcher.prototype.processPushFieldBlank=function(){this.processPushField(),this.processBlank()},Patcher.prototype.processPushElementCopy=function(){this.processPushElement(),this.processCopy()},Patcher.prototype.processPushElementBlank=function(){this.processPushElement(),this.processBlank()},Patcher.prototype.processReturnIntoObjectPop=function(){this.processReturnIntoObject(),this.processPop()},Patcher.prototype.processReturnIntoObjectSameKeyPop=function(){this.processReturnIntoObjectSameKey(),this.processPop()},Patcher.prototype.processReturnIntoArrayPop=function(){this.processReturnIntoArray(),this.processPop()},Patcher.prototype.processObjectSetFieldValue=function(){this.processValue(),this.processReturnIntoObject()},Patcher.prototype.processObjectCopyField=function(){this.processPushField(),this.processCopy(),this.processReturnIntoObjectSameKey(),this.processPop()},Patcher.prototype.processObjectDeleteField=function(){var idx=this.read(),entry=this.inputEntry(),key=this.inputKey(entry,idx),obj=this.outputObject();this.model.objectDeleteField(obj,key)},Patcher.prototype.processArrayAppendValue=function(){var value=this.model.wrap(this.read()),arr=this.outputArray();this.model.arrayAppendValue(arr,value)},Patcher.prototype.processArrayAppendSlice=function(){var left=this.read(),right=this.read(),str=this.outputArray(),val=this.inputEntry().value;this.model.arrayAppendSlice(str,val,left,right)},Patcher.prototype.processStringAppendString=function(){var value=this.model.wrap(this.read()),str=this.outputString();this.model.stringAppendValue(str,value)},Patcher.prototype.processStringAppendSlice=function(){var left=this.read(),right=this.read(),str=this.outputString(),val=this.inputEntry().value;this.model.stringAppendSlice(str,val,left,right)},Patcher}();function utf8charSize(code){return code>>16?4:code>>11?3:code>>7?2:1}function utf8resolveIndex(str,idx,start){void 0===start&&(start=0);var byteCount=start,ucsIdx=0;for(ucsIdx=start;byteCount<idx;ucsIdx++){var size=utf8charSize(str.codePointAt(ucsIdx));4===size&&ucsIdx++,byteCount+=size}return ucsIdx}var Model={wrap:function(data){return data},finalize:function(b){return Array.isArray(b)?b:b.data},markChanged:function(value){return value},objectGetKeys:function(value){return Object.keys(value)},objectGetField:function(value,key){return value[key]},arrayGetElement:function(value,idx){return value[idx]},copyObject:function(value){var res={type:"object",data:{}};if(null!==value)for(var _i=0,_a=Object.entries(value);_i<_a.length;_i++){var _b=_a[_i],key=_b[0],val=_b[1];res.data[key]=val}return res},copyArray:function(value){return null===value?[]:value.slice()},copyString:function(value){return{type:"string",data:null===value?"":value}},objectSetField:function(target,key,value){target.data[key]=value},objectDeleteField:function(target,key){delete target.data[key]},arrayAppendValue:function(target,value){target.push(value)},arrayAppendSlice:function(target,source,left,right){target.push.apply(target,source.slice(left,right))},stringAppendSlice:function(target,source,left,right){var sourceString=source,leftPos=utf8resolveIndex(sourceString,left),rightPos=utf8resolveIndex(sourceString,right,leftPos);target.data+=sourceString.slice(leftPos,rightPos)},stringAppendValue:function(target,value){target.data+=value}};var _templateObject,console=__webpack_require__("./node_modules/console-browserify/index.js");const isPolyfillEventSource=eventSource=>!(eventSource=>"undefined"!=typeof window&&eventSource.addEventListener===window.EventSource.prototype.addEventListener)(eventSource),addEventSourceListener=(eventSource,type,listener)=>{isPolyfillEventSource(eventSource)?eventSource.addEventListener(type,listener):eventSource.addEventListener(type,listener,!1)};function listen(EventSourceImpl,config,handlers){const{projectId,dataset,token}=config,headers=token?{Authorization:"Bearer ".concat(token)}:void 0,es=new EventSourceImpl("https://".concat(projectId,".api.sanity.io/v1/data/listen/").concat(dataset,"?query=*&effectFormat=mendoza"),{withCredentials:!0,headers});return addEventSourceListener(es,"welcome",handlers.open),addEventSourceListener(es,"mutation",function getMutationParser(cb){return msg=>{let data;try{data=JSON.parse(msg.data)}catch(err){return}cb(data)}}(handlers.next)),addEventSourceListener(es,"channelError",(msg=>{let data;es.close();try{data=JSON.parse(msg.data)}catch(err){return void handlers.error(new Error("Unknown error parsing listener message"))}handlers.error(new Error(data.message||data.error||"Listener returned HTTP ".concat(data.statusCode)))})),addEventSourceListener(es,"error",(err=>{const origin="undefined"!=typeof window&&window.location.origin,hintSuffix=origin?", and that the CORS-origin (".concat(origin,") is allowed"):"",errorMessage=function isErrorLike(err){return"object"==typeof err&&null!==err&&"message"in err}(err)?" (".concat(err.message,")"):"";handlers.error(new Error("Error establishing listener - check that the project ID and dataset are correct".concat(hintSuffix).concat(errorMessage)))})),{unsubscribe:()=>Promise.resolve(es.close())}}function getPublishedId(document){return function isDraft(doc){return doc._id.startsWith("drafts.")}(document)?document._id.slice(7):document._id}function applyPatchWithoutRev(doc,patch){const patchDoc={...doc};return delete patchDoc._rev,function applyPatch(left,patch){return new Patcher(Model,left,patch).process()}(patchDoc,patch)}const DEBOUNCE_MS=25;function noop(){return Promise.resolve()}function getSyncingDataset(config,onNotifyUpdate,_ref){let{getDocuments,EventSource}=_ref;const{projectId,dataset,listen:useListener,overlayDrafts,documentLimit,token,includeTypes}=config;let stagedDocs,previousTrx,flushTimeout;const onUpdate=docs=>{stagedDocs=void 0,flushTimeout=void 0,previousTrx=void 0,onNotifyUpdate(overlayDrafts?function overlay(documents){const overlayed=new Map;return documents.forEach((doc=>{const existing=overlayed.get(getPublishedId(doc));doc._id.startsWith("drafts.")?overlayed.set(getPublishedId(doc),function pretendThatItsPublished(doc){return{...doc,_id:getPublishedId(doc)}}(doc)):existing||overlayed.set(doc._id,doc)})),Array.from(overlayed.values())}(docs):docs)};if(!useListener){return{unsubscribe:noop,loaded:getDocuments({projectId,dataset,documentLimit,token,includeTypes}).then(onUpdate).then(noop)}}const indexedDocuments=new Map;let documents;const buffer=[];let onDoneLoading,onLoadError;const loaded=new Promise(((resolve,reject)=>{onDoneLoading=resolve,onLoadError=reject})),listener=listen(EventSource,config,{next:msg=>{documents?(applyMutation(msg),scheduleUpdate(documents,msg)):buffer.push(msg)},open:async()=>{const initial=await getDocuments({projectId,dataset,documentLimit,token,includeTypes});documents=function applyBufferedMutations(documents,mutations){const groups=new Map;return mutations.forEach((mutation=>{const group=groups.get(mutation.documentId)||[];group.push(mutation),groups.set(mutation.documentId,group)})),groups.forEach(((group,id)=>{const document=documents.find((doc=>doc._id===id));if(!document)return void console.warn("Received mutation for missing document %s",id);let hasFoundRevision=!1,current=document;group.forEach((mutation=>{hasFoundRevision=hasFoundRevision||mutation.previousRev===document._rev,hasFoundRevision&&mutation.effects&&(current=applyPatchWithoutRev(current,mutation.effects.apply))})),documents.splice(documents.indexOf(document),1,current)})),documents}(initial,buffer),documents.forEach((doc=>indexedDocuments.set(doc._id,doc))),onUpdate(documents),onDoneLoading()},error:error=>onLoadError(error)}),scheduleUpdate=(docs,msg)=>{clearTimeout(flushTimeout),previousTrx!==msg.transactionId&&stagedDocs?(onUpdate(stagedDocs),previousTrx=void 0):(previousTrx=msg.transactionId,stagedDocs=docs.slice()),flushTimeout=setTimeout(onUpdate,DEBOUNCE_MS,docs.slice())},applyMutation=msg=>{if(!msg.effects||msg.documentId.startsWith("_."))return;const document=indexedDocuments.get(msg.documentId)||null;replaceDocument(msg.documentId,applyPatchWithoutRev(document,msg.effects.apply))},replaceDocument=(id,document)=>{const current=indexedDocuments.get(id),docs=documents||[],position=current?docs.indexOf(current):-1;-1===position&&document?(docs.push(document),indexedDocuments.set(id,document)):document?(docs.splice(position,1,document),indexedDocuments.set(id,document)):(docs.splice(position,1),indexedDocuments.delete(id))};return{unsubscribe:listener.unsubscribe,loaded}}function groqStore$1(config,envImplementations){let documents=[];const executeThrottled=throttle(config.subscriptionThrottleMs||50,(function executeAllSubscriptions(){activeSubscriptions.forEach(executeQuerySubscription)})),activeSubscriptions=[];let dataset;async function loadDataset(){dataset||(dataset=getSyncingDataset(config,(docs=>{documents=docs,executeThrottled()}),envImplementations)),await dataset.loaded}async function query(groqQuery,params){await loadDataset();const tree=parse(groqQuery,{params}),result=await function evaluateQuery(tree){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const root=fromJS(options.root),dataset=fromJS(options.dataset),params={...options.params};return evaluate(tree,new Scope(params,dataset,root,{timestamp:options.timestamp||new Date,identity:void 0===options.identity?"me":options.identity,sanity:options.sanity,after:options.after?fromJS(options.after):null,before:options.before?fromJS(options.before):null},null))}(tree,{dataset:documents,params});return result.get()}function executeQuerySubscription(subscription){return query(subscription.query,subscription.params).then((res=>{"previousResult"in subscription&&fast_deep_equal_default()(subscription.previousResult,res)||(subscription.previousResult=res,subscription.callback(void 0,res))})).catch((err=>{subscription.callback(err)}))}return{query,getDocument:async function getDocument(documentId){return await loadDataset(),query(groq(_templateObject||(_templateObject=function _taggedTemplateLiteral(strings,raw){return raw||(raw=strings.slice(0)),Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}))}(["*[_id == $id][0]"]))),{id:documentId})},getDocuments:async function getDocuments(documentIds){await loadDataset();const subQueries=documentIds.map((id=>'*[_id == "'.concat(id,'"][0]'))).join(",\n");return query("[".concat(subQueries,"]"))},subscribe:function subscribe(groqQuery,params,callback){if(!config.listen)throw new Error("Cannot use `subscribe()` without `listen: true`");const subscription={query:groqQuery,params,callback};activeSubscriptions.push(subscription);let unsubscribed=!1;return executeQuerySubscription(subscription),{unsubscribe:()=>(unsubscribed||(unsubscribed=!0,activeSubscriptions.splice(activeSubscriptions.indexOf(subscription),1)),Promise.resolve())}},close:function close(){return executeThrottled.cancel(),dataset?dataset.unsubscribe():Promise.resolve()}}}const getDocuments=async function getDocuments2(_ref2){let{projectId,dataset,token,documentLimit,includeTypes=[]}=_ref2;const baseUrl="https://".concat(projectId,".api.sanity.io/v1/data/export/").concat(dataset),params=includeTypes.length>0?new URLSearchParams({types:null==includeTypes?void 0:includeTypes.join(",")}):"",url="".concat(baseUrl,"?").concat(params),headers=token?{Authorization:"Bearer ".concat(token)}:void 0,response=await fetch(url,{credentials:"include",headers});if(200!==response.status)throw new Error("Error streaming dataset: ".concat(function getError(body){if("object"==typeof body&&"error"in body&&"message"in body)return body.message||body.error;return"<unknown error>"}(await response.json())));const stream=function getDocumentStream(body){if(!body)throw new Error("Failed to read body from response");let reader,cancelled=!1;function cancel(){cancelled=!0,reader&&reader.cancel()}return new ReadableStream({start(controller){reader=body.getReader();const decoder=new TextDecoder;let buffer="";async function processResult(result){if(result.done){if(cancelled)return;return buffer=buffer.trim(),0===buffer.length?void controller.close():(controller.enqueue(JSON.parse(buffer)),void controller.close())}buffer+=decoder.decode(result.value,{stream:!0});const lines=buffer.split("\n");for(let i=0;i<lines.length-1;++i){const line=lines[i].trim();if(0!==line.length)try{controller.enqueue(JSON.parse(line))}catch(err){return controller.error(err),void cancel()}}if(buffer=lines[lines.length-1],reader)try{processResult(await reader.read())}catch(err){controller.error(err)}}reader.read().then(processResult).catch((err=>controller.error(err)))},cancel})}(response.body),reader=stream.getReader(),documents=[];let result,document;do{if(result=await reader.read(),document=result.value,isStreamError(document))throw new Error("Error streaming dataset: ".concat(document.error));if(document&&!document._id.startsWith("_.")&&documents.push(document),documentLimit&&documents.length>documentLimit)throw reader.cancel("Reached document limit"),new Error("Error streaming dataset: Reached limit of ".concat(documentLimit," documents. Try using the includeTypes option to reduce the amount of documents, or increase the limit."))}while(!result.done);return documents};function isStreamError(result){return!!result&&("error"in result&&"object"==typeof result.error&&null!==result.error&&("description"in result.error&&"string"==typeof result.error.description&&!("_id"in result)))}function groqStore(config){var _a;!function assertEnvSupport(){const unsupported=["EventSource","ReadableStream","fetch"].filter((api=>!(api in window)));if(unsupported.length>0)throw new Error("Browser not supported. Missing browser APIs: ".concat(unsupported.join(", ")))}();const EventSource=null!=(_a=config.EventSource)?_a:window.EventSource;if(config.token){if(!config.EventSource)throw new Error("When the `token` option is used the `EventSource` option must also be provided.");if(config.EventSource===window.EventSource)throw new Error("When the `token` option is used the `EventSource` option must also be provided. EventSource cannot be `window.EventSource`, as it does not support passing a token.")}return groqStore$1(config,{EventSource,getDocuments})}},"./node_modules/fast-deep-equal/index.js":module=>{module.exports=function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){if(a.constructor!==b.constructor)return!1;var length,i,keys;if(Array.isArray(a)){if((length=a.length)!=b.length)return!1;for(i=length;0!=i--;)if(!equal(a[i],b[i]))return!1;return!0}if(a.constructor===RegExp)return a.source===b.source&&a.flags===b.flags;if(a.valueOf!==Object.prototype.valueOf)return a.valueOf()===b.valueOf();if(a.toString!==Object.prototype.toString)return a.toString()===b.toString();if((length=(keys=Object.keys(a)).length)!==Object.keys(b).length)return!1;for(i=length;0!=i--;)if(!Object.prototype.hasOwnProperty.call(b,keys[i]))return!1;for(i=length;0!=i--;){var key=keys[i];if(!equal(a[key],b[key]))return!1}return!0}return a!=a&&b!=b}}}]);